{"version":3,"sources":["../src/commands/main.ts","../src/commands/args.ts","../src/lib/readers.ts","../src/lib/utils.ts","../src/lib/statusandheaders.ts","../src/lib/warcrecord.ts","../src/lib/warcparser.ts","../src/lib/indexer.ts","../src/cli.ts"],"sourcesContent":["import { lstatSync, createReadStream } from \"fs\";\nimport { basename } from \"path\";\nimport yargs from \"yargs\";\n\nimport { indexCommandArgs, cdxIndexCommandArgs } from \"./args\";\nimport { Indexer, CDXIndexer, StreamResults } from \"../lib\";\n\nconst BUFF_SIZE = 1024 * 128;\n\n// ===========================================================================\nexport function main(\n  args: string[] = [],\n  out: NodeJS.WriteStream = process.stdout\n) {\n  let promise = Promise.resolve();\n\n  yargs\n    .usage(\"$0 [command]\")\n    // Basic Indexer\n    .command({\n      command: \"index <filename..>\",\n      describe: \"Index WARC(s)\",\n      builder: (yargs) => {\n        return indexCommandArgs;\n      },\n      handler: async (args) => {\n        promise = new Indexer(args, out).run(loadStreams([args.filename]));\n      },\n    })\n    // CDX Indexer\n    .command({\n      command: \"cdx-index <filename..>\",\n      describe: \"CDX(J) Index of WARC(s)\",\n      builder: (yargs) => {\n        return cdxIndexCommandArgs;\n      },\n      handler: async (args) => {\n        promise = new CDXIndexer(args, out).run(loadStreams([args.filename]));\n      },\n    })\n    .demandCommand(1, \"Please specify a command\")\n    .strictCommands()\n    .help()\n    .parseAsync(args);\n\n  return promise;\n}\n\nfunction loadStreams(filenames: string[]) {\n  return filenames.reduce<StreamResults>((accumulator, filename) => {\n    if (!lstatSync(filename).isFile()) {\n      process.stderr.write(`Skipping ${filename}, not a file\\n`);\n      return accumulator;\n    }\n\n    const reader = createReadStream(filename, { highWaterMark: BUFF_SIZE });\n    filename = basename(filename);\n    accumulator.push({ filename, reader });\n    return accumulator;\n  }, []);\n}\n","import yargs from \"yargs\";\n\nexport const indexCommandArgs = yargs\n  .positional(\"filename\", {\n    describe: \"WARC file(s) to index\",\n    type: \"string\",\n    demandOption: \"true\",\n  })\n  .option(\"f\", {\n    alias: \"fields\",\n    describe: \"fields to include in index\",\n    type: \"string\",\n  });\n\nexport type IndexCommandArgs = Awaited<typeof indexCommandArgs.argv>;\n\nexport const cdxIndexCommandArgs = yargs\n  .positional(\"filename\", {\n    describe: \"WARC file(s) to index\",\n    type: \"string\",\n    demandOption: \"true\",\n  })\n  .option(\"a\", {\n    alias: \"all\",\n    describe: \"index all WARC records\",\n    type: \"boolean\",\n  })\n  .option(\"format\", {\n    describe: \"output format\",\n    choices: [\"json\", \"cdxj\", \"cdx\"],\n    default: \"cdxj\",\n  })\n  .option(\"noSurt\", {\n    describe:\n      \"Use plain urlkey, do not convert to SURT form (Sort-friendly URI Reordering Transform)\",\n    type: \"boolean\",\n  });\n\nexport type CdxIndexCommandArgs = Awaited<typeof cdxIndexCommandArgs.argv>;\n","/*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n\nimport { ReadStream } from \"fs\";\nimport { Inflate, InflateOptions, ReturnCodes } from \"pako\";\n\nimport { splitChunk, concatChunks } from \"./utils\";\n\nconst decoder = new TextDecoder(\"utf-8\");\n\n// ===========================================================================\nclass NoConcatInflator extends Inflate {\n  reader: AsyncIterReader;\n  ended = false;\n  chunks: Uint8Array[] = [];\n\n  constructor(options: InflateOptions, reader: AsyncIterReader) {\n    super(options);\n    this.reader = reader;\n  }\n\n  override onEnd(status: ReturnCodes) {\n    this.err = status;\n    if (!this.err) {\n      // @ts-expect-error strm is not implemented in typescript types\n      this.reader._rawOffset += this.strm.total_in;\n    }\n  }\n}\n\n// ===========================================================================\nexport abstract class BaseAsyncIterReader {\n  static async readFully(\n    iter?: AsyncGenerator<Uint8Array, void, unknown> | BaseAsyncIterReader\n  ) {\n    if (!iter) {\n      return [0, new Uint8Array()] as const;\n    }\n    const chunks = [];\n    let size = 0;\n\n    for await (const chunk of iter) {\n      chunks.push(chunk);\n      size += chunk.byteLength;\n    }\n\n    return [size, concatChunks(chunks, size)] as const;\n  }\n\n  abstract [Symbol.asyncIterator](): AsyncGenerator<Uint8Array, void, unknown>;\n\n  getReadableStream() {\n    const streamIter = this[Symbol.asyncIterator]();\n\n    return new ReadableStream({\n      pull(controller) {\n        return streamIter.next().then((result) => {\n          // all done;\n          if (result.done || !result.value) {\n            controller.close();\n          } else {\n            controller.enqueue(result.value);\n          }\n        });\n      },\n    });\n  }\n\n  async readFully(): Promise<Uint8Array> {\n    return (\n      await BaseAsyncIterReader.readFully(this[Symbol.asyncIterator]())\n    )[1];\n  }\n\n  abstract readlineRaw(maxLength?: number): Promise<Uint8Array | null>;\n\n  async readline(maxLength: number = 0) {\n    const lineBuff = await this.readlineRaw(maxLength);\n    return lineBuff ? decoder.decode(lineBuff) : \"\";\n  }\n\n  async *iterLines(maxLength: number = 0) {\n    let line = null;\n\n    while ((line = await this.readline(maxLength))) {\n      yield line;\n    }\n  }\n}\n\ntype AsyncIterReaderOpts = {\n  raw: boolean;\n};\n\nfunction isIterator(input: any): input is Generator<Uint8Array, void, unknown> {\n  return input && Symbol.iterator in input;\n}\nfunction isAsyncIterator(\n  input: any\n): input is AsyncGenerator<Uint8Array, void, unknown> {\n  return input && Symbol.asyncIterator in input;\n}\n\n// ===========================================================================\nexport class AsyncIterReader extends BaseAsyncIterReader {\n  compressed!: string | null;\n  opts!: AsyncIterReaderOpts;\n  inflator!: NoConcatInflator | null;\n\n  _sourceIter: AsyncIterator<Uint8Array | null>;\n\n  lastValue: Uint8Array | null;\n  errored: boolean;\n  _savedChunk: Uint8Array | null;\n  _rawOffset: number;\n  _readOffset: number;\n  numChunks: number;\n\n  constructor(\n    streamOrIter:\n      | ReadStream\n      | ReadableStream<Uint8Array>\n      | AsyncGenerator<Uint8Array, void, unknown>\n      | BaseAsyncIterReader\n      | Uint8Array[]\n      | Generator<Uint8Array, void, unknown>,\n    compressed = \"gzip\",\n    dechunk = false\n  ) {\n    super();\n    this.compressed = compressed;\n    this.opts = { raw: compressed === \"deflateRaw\" };\n\n    this.inflator = compressed ? new NoConcatInflator(this.opts, this) : null;\n\n    let source: {\n      [Symbol.asyncIterator](): AsyncGenerator<Uint8Array, void, unknown>;\n    };\n    if (streamOrIter instanceof ReadableStream) {\n      source = AsyncIterReader.fromReadable(streamOrIter.getReader());\n    } else if (streamOrIter instanceof ReadStream) {\n      source = AsyncIterReader.fromReadable(streamOrIter);\n    } else if (streamOrIter instanceof BaseAsyncIterReader) {\n      source = streamOrIter[Symbol.asyncIterator]();\n    } else if (\n      isAsyncIterator(streamOrIter) &&\n      typeof streamOrIter[Symbol.asyncIterator] === \"function\"\n    ) {\n      source = streamOrIter;\n    } else if (\n      isIterator(streamOrIter) &&\n      typeof streamOrIter[Symbol.iterator] === \"function\"\n    ) {\n      source = AsyncIterReader.fromIter(streamOrIter);\n    } else if (Array.isArray(streamOrIter)) {\n      source = AsyncIterReader.fromIter(streamOrIter);\n    } else {\n      throw new TypeError(\"Invalid Stream Source\");\n    }\n\n    if (dechunk) {\n      this._sourceIter = this.dechunk(source[Symbol.asyncIterator]());\n    } else {\n      this._sourceIter = source[Symbol.asyncIterator]();\n    }\n\n    this.lastValue = null;\n\n    this.errored = false;\n\n    this._savedChunk = null;\n\n    this._rawOffset = 0;\n    this._readOffset = 0;\n\n    this.numChunks = 0;\n  }\n\n  async _loadNext() {\n    const res = await this._sourceIter.next();\n    return !res.done ? res.value : null;\n  }\n\n  async *dechunk(\n    source: AsyncGenerator<Uint8Array, void, unknown>\n  ): AsyncIterator<Uint8Array | null> {\n    const reader =\n      source instanceof AsyncIterReader ? source : new AsyncIterReader(source);\n\n    let size = -1;\n    let newSize = -1;\n    let first = true;\n\n    while (size != 0) {\n      const lineBuff = await reader.readlineRaw(64);\n      let chunk: Uint8Array = new Uint8Array();\n\n      size = lineBuff ? parseInt(decoder.decode(lineBuff), 16) : 0;\n\n      if (!size || size > 2 ** 32) {\n        if (Number.isNaN(size) || size > 2 ** 32) {\n          if (!first) {\n            this.errored = true;\n          }\n          yield lineBuff;\n          break;\n        }\n      } else {\n        [newSize, chunk] = await reader.readSize(size);\n        if (chunk.length != size) {\n          if (!first) {\n            this.errored = true;\n          } else {\n            yield lineBuff;\n          }\n          yield chunk;\n          break;\n        }\n      }\n\n      const sep = (await reader.readSize(2))[1];\n\n      if (sep[0] != 13 || sep[1] != 10) {\n        if (!first) {\n          this.errored = true;\n        } else {\n          yield lineBuff;\n        }\n        yield chunk;\n        yield sep;\n        break;\n      } else {\n        first = false;\n        if (!chunk || size === 0) {\n          return;\n        } else {\n          yield chunk;\n        }\n      }\n    }\n\n    yield* reader;\n  }\n\n  unread(chunk: Uint8Array) {\n    if (!chunk.length) {\n      return;\n    }\n\n    this._readOffset -= chunk.length;\n\n    /* istanbul ignore if */\n    if (this._savedChunk) {\n      console.log(\"Already have chunk!\");\n    }\n\n    this._savedChunk = chunk;\n  }\n\n  async _next() {\n    if (this._savedChunk) {\n      const chunk = this._savedChunk;\n      this._savedChunk = null;\n      return chunk;\n    }\n\n    if (this.compressed) {\n      const newValue = this._getNextChunk();\n      if (newValue) {\n        return newValue;\n      }\n    }\n\n    let value = await this._loadNext();\n\n    while (this.compressed && value) {\n      this._push(value);\n\n      const newValue = this._getNextChunk(value);\n      if (newValue) {\n        return newValue;\n      }\n      value = await this._loadNext();\n    }\n\n    return value;\n  }\n\n  _push(value: Uint8Array) {\n    // only called if this.compressed === true\n    if (!this.inflator) {\n      throw new Error(\n        \"AsyncIterReader cannot call _push when this.compressed === true\"\n      );\n    }\n    this.lastValue = value;\n\n    if (this.inflator.ended) {\n      this.inflator = new NoConcatInflator(this.opts, this);\n    }\n    this.inflator.push(value);\n\n    // \"deflate\" allows automatically trying \"deflateRaw\", while \"gzip\" does not\n    if (\n      this.inflator.err &&\n      this.inflator.ended &&\n      this.compressed === \"deflate\" &&\n      this.opts.raw === false &&\n      this.numChunks === 0\n    ) {\n      this.opts.raw = true;\n      this.compressed = \"deflateRaw\";\n\n      this.inflator = new NoConcatInflator(this.opts, this);\n      this.inflator.push(value);\n    }\n  }\n\n  _getNextChunk(original?: Uint8Array) {\n    // only called if this.compressed === true\n    if (!this.inflator) {\n      throw new Error(\n        \"AsyncIterReader cannot call _getNextChunk when this.compressed === true\"\n      );\n    }\n    while (true) {\n      if (this.inflator.chunks.length > 0) {\n        this.numChunks++;\n        return this.inflator.chunks.shift();\n      }\n\n      if (this.inflator.ended) {\n        if (this.inflator.err !== 0) {\n          // assume not compressed\n          this.compressed = null;\n          return original;\n        }\n\n        // @ts-expect-error strm is not implemented in typescript types\n        const avail_in = this.inflator.strm.avail_in;\n\n        if (avail_in && this.lastValue) {\n          this._push(this.lastValue.slice(-avail_in));\n          continue;\n        }\n      }\n\n      return null;\n    }\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let chunk = null;\n    while ((chunk = await this._next())) {\n      this._readOffset += chunk.length;\n      yield chunk;\n    }\n  }\n\n  async readlineRaw(maxLength?: number) {\n    const chunks = [];\n    let size = 0;\n\n    let inx = -1;\n\n    let lastChunk = null;\n\n    for await (const chunk of this) {\n      if (maxLength && size + chunk.byteLength > maxLength) {\n        lastChunk = chunk;\n        inx = maxLength - size - 1;\n        const lineInx = chunk.slice(0, inx + 1).indexOf(10);\n        if (lineInx >= 0) {\n          inx = lineInx;\n        }\n        break;\n      }\n\n      inx = chunk.indexOf(10);\n\n      if (inx >= 0) {\n        lastChunk = chunk;\n        break;\n      }\n\n      chunks.push(chunk);\n      size += chunk.byteLength;\n    }\n\n    if (lastChunk) {\n      const [first, remainder] = splitChunk(lastChunk, inx + 1);\n      chunks.push(first);\n      size += first.byteLength;\n\n      this.unread(remainder);\n    } else if (!chunks.length) {\n      return null;\n    }\n\n    return concatChunks(chunks, size);\n  }\n\n  override async readFully(): Promise<Uint8Array> {\n    return (await this.readSize())[1];\n  }\n\n  async readSize(sizeLimit = -1, skip = false) {\n    const chunks: Uint8Array[] = [];\n    let size = 0;\n\n    //while ((res = await this._readiter.next()) && (chunk = res.value)) {\n    for await (const chunk of this) {\n      if (sizeLimit >= 0) {\n        if (chunk.length > sizeLimit) {\n          const [first, remainder] = splitChunk(chunk, sizeLimit);\n          if (!skip) {\n            chunks.push(first);\n          }\n          size += first.byteLength;\n          this.unread(remainder);\n          break;\n        } else if (chunk.length === sizeLimit) {\n          if (!skip) {\n            chunks.push(chunk);\n          }\n          size += chunk.byteLength;\n          sizeLimit = 0;\n          break;\n        } else {\n          sizeLimit -= chunk.length;\n        }\n      }\n      if (!skip) {\n        chunks.push(chunk);\n      }\n      size += chunk.byteLength;\n    }\n\n    if (skip) {\n      return [size, new Uint8Array()] as const;\n    }\n    return [size, concatChunks(chunks, size)] as const;\n  }\n\n  getReadOffset() {\n    return this._readOffset;\n  }\n\n  getRawOffset() {\n    return this.compressed ? this._rawOffset : this._readOffset;\n  }\n\n  getRawLength(prevOffset: number): number {\n    return this.compressed\n      ? // @ts-expect-error strm is not implemented in typescript types\n        this.inflator.strm.total_in\n      : this._readOffset - prevOffset;\n  }\n\n  static fromReadable(\n    source: ReadStream | ReadableStreamDefaultReader<Uint8Array>\n  ) {\n    const iterable = {\n      async *[Symbol.asyncIterator]() {\n        let res = null;\n\n        while ((res = await source.read()) && !res.done) {\n          yield res.value as Uint8Array;\n        }\n      },\n    };\n\n    return iterable;\n  }\n\n  static fromIter(source: Generator<Uint8Array, void, unknown> | Uint8Array[]) {\n    const iterable = {\n      async *[Symbol.asyncIterator]() {\n        for (const chunk of source) {\n          yield chunk;\n        }\n      },\n    };\n\n    return iterable;\n  }\n}\n\n// ===========================================================================\nexport class LimitReader extends BaseAsyncIterReader {\n  sourceIter!: AsyncIterReader;\n  length!: number;\n  limit!: number;\n  skip!: number;\n\n  constructor(streamIter: AsyncIterReader, limit: number, skip = 0) {\n    super();\n    this.sourceIter = streamIter;\n    this.length = limit;\n    this.limit = limit;\n    this.skip = skip;\n  }\n\n  setLimitSkip(limit: number, skip = 0) {\n    this.limit = limit;\n    this.skip = skip;\n  }\n\n  async *[Symbol.asyncIterator]() {\n    if (this.limit <= 0) {\n      return;\n    }\n\n    for await (let chunk of this.sourceIter) {\n      if (this.skip > 0) {\n        if (chunk.length >= this.skip) {\n          const [, /*first*/ remainder] = splitChunk(chunk, this.skip);\n          chunk = remainder;\n          this.skip = 0;\n        } else {\n          this.skip -= chunk.length;\n          continue;\n        }\n      }\n\n      if (chunk.length > this.limit) {\n        const [first, remainder] = splitChunk(chunk, this.limit);\n        chunk = first;\n\n        if (this.sourceIter.unread) {\n          this.sourceIter.unread(remainder);\n        }\n      }\n\n      if (chunk.length) {\n        this.limit -= chunk.length;\n\n        yield chunk;\n      }\n\n      if (this.limit <= 0) {\n        break;\n      }\n    }\n  }\n\n  async readlineRaw(maxLength?: number) {\n    if (this.limit <= 0) {\n      return null;\n    }\n\n    const result = await this.sourceIter.readlineRaw(\n      maxLength ? Math.min(maxLength, this.limit) : this.limit\n    );\n    this.limit -= result?.length || 0;\n    return result;\n  }\n\n  async skipFully() {\n    const origLimit = this.limit;\n\n    while (this.limit > 0) {\n      this.limit -= (await this.sourceIter.readSize(this.limit, true))[0];\n    }\n\n    return origLimit;\n  }\n}\n\n// ===========================================================================\n","import { Request } from \"./types\";\n\nexport function binaryToString(data: Uint8Array | string) {\n  let string;\n\n  if (typeof data === \"string\") {\n    string = data;\n  } else if (data && data.length) {\n    string = data.reduce((accumulator, value) => {\n      accumulator += String.fromCharCode(value);\n      return accumulator;\n    }, \"\");\n  } else if (data) {\n    string = data.toString();\n  } else {\n    string = \"\";\n  }\n  return \"__wb_post_data=\" + btoa(string);\n}\n\nexport function rxEscape(string: string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\n\nexport function getSurt(url: string) {\n  try {\n    if (!url.startsWith(\"https:\") && !url.startsWith(\"http:\")) {\n      return url;\n    }\n    url = url.replace(/^(https?:\\/\\/)www\\d*\\./, \"$1\");\n    const urlLower = url.toLowerCase();\n    const urlObj = new URL(urlLower);\n\n    const hostParts = urlObj.hostname.split(\".\").reverse();\n    let surt = hostParts.join(\",\");\n    if (urlObj.port) {\n      surt += \":\" + urlObj.port;\n    }\n    surt += \")\";\n    surt += urlObj.pathname;\n    if (urlObj.search) {\n      urlObj.searchParams.sort();\n      surt += urlObj.search;\n      for (const [key, value] of urlObj.searchParams.entries()) {\n        if (!value) {\n          const rx = new RegExp(`(?<=[&?])${rxEscape(key)}=(?=&|$)`);\n          if (!rx.exec(urlLower)) {\n            surt = surt.replace(rx, key);\n          }\n        }\n      }\n    }\n    return surt;\n  } catch (e) {\n    return url;\n  }\n}\n\nexport function postToGetUrl(request: Request) {\n  let { method, headers, postData } = request;\n\n  if (method === \"GET\") {\n    return false;\n  }\n\n  const requestMime = (headers.get(\"content-type\") || \"\").split(\";\")[0];\n\n  function decodeIfNeeded(postData: Uint8Array | string): string {\n    if (postData instanceof Uint8Array) {\n      postData = new TextDecoder().decode(postData);\n    }\n    return postData;\n  }\n\n  let query = \"\";\n\n  switch (requestMime) {\n    case \"application/x-www-form-urlencoded\":\n      query = decodeIfNeeded(postData);\n      break;\n\n    case \"application/json\":\n      query = jsonToQueryString(decodeIfNeeded(postData));\n      break;\n\n    case \"text/plain\":\n      try {\n        query = jsonToQueryString(decodeIfNeeded(postData), false);\n      } catch (e) {\n        query = binaryToString(postData);\n      }\n      break;\n\n    case \"multipart/form-data\":\n      const content_type = headers.get(\"content-type\");\n      if (!content_type) {\n        throw new Error(\n          \"utils cannot call postToGetURL when missing content-type header\"\n        );\n      }\n      query = mfdToQueryString(decodeIfNeeded(postData), content_type);\n      break;\n\n    default:\n      query = binaryToString(postData);\n  }\n\n  if (query !== null) {\n    request.url = appendRequestQuery(request.url, query, request.method);\n    request.method = \"GET\";\n    request.requestBody = query;\n    return true;\n  }\n\n  return false;\n}\n\nexport function appendRequestQuery(url: string, query: string, method: string) {\n  if (!method) {\n    return url;\n  }\n\n  const start = url.indexOf(\"?\") > 0 ? \"&\" : \"?\";\n\n  return `${url}${start}__wb_method=${method}&${query}`;\n}\n\nexport function jsonToQueryParams(json: string | any, ignoreInvalid = true) {\n  if (typeof json === \"string\") {\n    try {\n      json = JSON.parse(json);\n    } catch (e) {\n      json = {};\n    }\n  }\n\n  const q = new URLSearchParams();\n\n  const dupes: Record<string, number> = {};\n\n  const getKey = (key: string) => {\n    if (!q.has(key)) {\n      return key;\n    }\n\n    if (!(key in dupes)) {\n      dupes[key] = 1;\n    }\n    return key + \".\" + ++dupes[key] + \"_\";\n  };\n\n  try {\n    JSON.stringify(json, (k, v) => {\n      if (![\"object\", \"function\"].includes(typeof v)) {\n        q.set(getKey(k), v);\n      }\n      return v;\n    });\n  } catch (e) {\n    if (!ignoreInvalid) {\n      throw e;\n    }\n  }\n\n  return q;\n}\n\nexport function mfdToQueryParams(\n  mfd: string | Uint8Array,\n  contentType: string\n) {\n  const params = new URLSearchParams();\n\n  if (mfd instanceof Uint8Array) {\n    mfd = new TextDecoder().decode(mfd);\n  }\n\n  try {\n    const boundary = contentType.split(\"boundary=\")[1];\n\n    const parts = mfd.split(new RegExp(\"-*\" + boundary + \"-*\", \"mi\"));\n\n    for (let i = 0; i < parts.length; i++) {\n      const m = parts[i]!.trim().match(/name=\"([^\"]+)\"\\r\\n\\r\\n(.*)/im);\n      if (m) {\n        params.set(m[1]!, m[2]!);\n      }\n    }\n  } catch (e) {\n    // ignore invalid, don't add params\n  }\n\n  return params;\n}\n\nexport function jsonToQueryString(json: any, ignoreInvalid = true) {\n  return jsonToQueryParams(json, ignoreInvalid).toString();\n}\n\nexport function mfdToQueryString(\n  mfd: string | Uint8Array,\n  contentType: string\n) {\n  return mfdToQueryParams(mfd, contentType).toString();\n}\n\n// ===========================================================================\n// parsing utils\n\nexport function concatChunks(chunks: Uint8Array[], size: number): Uint8Array {\n  if (chunks.length === 1) {\n    return chunks[0] as Uint8Array;\n  }\n  const buffer = new Uint8Array(size);\n\n  let offset = 0;\n\n  for (const chunk of chunks) {\n    buffer.set(chunk, offset);\n    offset += chunk.byteLength;\n  }\n\n  return buffer;\n}\n\nexport function splitChunk(\n  chunk: Uint8Array,\n  inx: number\n): [Uint8Array, Uint8Array] {\n  return [chunk.slice(0, inx), chunk.slice(inx)];\n}\n","import { concatChunks, splitChunk } from \"./utils\";\nimport { AsyncIterReader } from \"./readers\";\n\nexport const CRLF = new Uint8Array([13, 10]);\nexport const CRLFCRLF = new Uint8Array([13, 10, 13, 10]);\n\nconst decoder = new TextDecoder(\"utf-8\");\n\n// ===========================================================================\nexport class StatusAndHeaders {\n  statusline: string;\n  headers: Map<string, string> | Headers;\n\n  constructor({\n    statusline,\n    headers,\n  }: {\n    statusline: string;\n    headers: Map<string, string> | Headers;\n  }) {\n    this.statusline = statusline;\n    this.headers = headers;\n  }\n\n  toString() {\n    const buff = [this.statusline];\n\n    for (const [name, value] of this.headers) {\n      buff.push(`${name}: ${value}`);\n    }\n\n    return buff.join(\"\\r\\n\") + \"\\r\\n\";\n  }\n\n  async *iterSerialize(encoder: TextEncoder) {\n    yield encoder.encode(this.statusline);\n    yield CRLF;\n    for (const [name, value] of this.headers) {\n      yield encoder.encode(`${name}: ${value}\\r\\n`);\n    }\n  }\n\n  _protocol!: string;\n  _statusCode!: number | string;\n  _statusText!: string;\n\n  _parseResponseStatusLine() {\n    const parts = splitRemainder(this.statusline, \" \", 2);\n    this._protocol = parts[0] ?? \"\";\n    this._statusCode = parts.length > 1 ? Number(parts[1]) : \"\";\n    this._statusText = parts.length > 2 ? parts[2]! : \"\";\n  }\n\n  get statusCode() {\n    if (this._statusCode === undefined) {\n      this._parseResponseStatusLine();\n    }\n    return this._statusCode;\n  }\n\n  get protocol() {\n    if (this._protocol === undefined) {\n      this._parseResponseStatusLine();\n    }\n    return this._protocol;\n  }\n\n  get statusText() {\n    if (this._statusText === undefined) {\n      this._parseResponseStatusLine();\n    }\n    return this._statusText;\n  }\n\n  _method!: string;\n  _requestPath!: string;\n\n  _parseRequestStatusLine() {\n    const parts = this.statusline.split(\" \", 2);\n    this._method = parts[0] ?? \"\";\n    this._requestPath = parts.length > 1 ? parts[1]! : \"\";\n  }\n\n  get method() {\n    if (this._method === undefined) {\n      this._parseRequestStatusLine();\n    }\n    return this._method;\n  }\n\n  get requestPath() {\n    if (this._requestPath === undefined) {\n      this._parseRequestStatusLine();\n    }\n    return this._requestPath;\n  }\n}\n\n// ===========================================================================\nexport class StatusAndHeadersParser {\n  async parse(\n    reader: AsyncIterReader,\n    {\n      headersClass,\n      firstLine,\n    }: { firstLine?: string; headersClass: typeof Map | typeof Headers } = {\n      headersClass: Map,\n    }\n  ) {\n    const fullStatusLine = firstLine ? firstLine : await reader.readline();\n\n    if (!fullStatusLine) {\n      return null;\n    }\n\n    const statusline = fullStatusLine.trimEnd();\n\n    if (!statusline) {\n      return null;\n    }\n\n    const headers = new headersClass();\n\n    const headerBuff = await readToDoubleCRLF(reader);\n\n    let start = 0;\n    let nameEnd, valueStart, valueEnd;\n    let name = \"\";\n    let value;\n\n    while (start < headerBuff.length) {\n      valueEnd = headerBuff.indexOf(\"\\n\", start);\n\n      if (value && (headerBuff[start] === \" \" || headerBuff[start] === \"\\t\")) {\n        value += headerBuff\n          .slice(start, valueEnd < 0 ? undefined : valueEnd)\n          .trimEnd();\n      } else {\n        if (value) {\n          try {\n            headers.set(name, value);\n          } catch (e) {\n            // ignore\n          }\n          value = null;\n        }\n\n        nameEnd = headerBuff.indexOf(\":\", start);\n\n        valueStart = nameEnd < 0 ? start : nameEnd + 1;\n\n        if (nameEnd >= 0 && nameEnd < valueEnd) {\n          name = headerBuff.slice(start, nameEnd).trimStart();\n          value = headerBuff\n            .slice(valueStart, valueEnd < 0 ? undefined : valueEnd)\n            .trim();\n        } else {\n          value = null;\n        }\n      }\n\n      if (valueEnd < 0) {\n        break;\n      }\n\n      start = valueEnd + 1;\n    }\n\n    if (value) {\n      try {\n        headers.set(name, value);\n      } catch (e) {\n        // ignore\n      }\n    }\n\n    return new StatusAndHeaders({\n      statusline,\n      headers,\n    });\n  }\n}\n\n// ===========================================================================\nfunction splitRemainder(str: string, sep: string, limit: number) {\n  const parts = str.split(sep);\n  const newParts = parts.slice(0, limit);\n  const rest = parts.slice(limit);\n  if (rest.length > 0) {\n    newParts.push(parts.slice(limit).join(sep));\n  }\n  return newParts;\n}\n\n// ===========================================================================\nexport async function indexOfDoubleCRLF(\n  buffer: Uint8Array,\n  iter: AsyncIterator<Uint8Array, void, unknown>\n) {\n  let start = 0;\n\n  for (let i = 0; i < buffer.length - 4; i++) {\n    const inx = buffer.indexOf(13, start);\n    if (inx < 0) {\n      break;\n    }\n\n    if (inx + 3 >= buffer.length) {\n      const { value } = await iter.next();\n      if (!value) {\n        break;\n      }\n\n      const newBuff = new Uint8Array(value.length + buffer.length);\n      newBuff.set(buffer, 0);\n      newBuff.set(value, buffer.length);\n      buffer = newBuff;\n    }\n\n    if (\n      buffer[inx + 1] === 10 &&\n      buffer[inx + 2] === 13 &&\n      buffer[inx + 3] === 10\n    ) {\n      return [inx + 3, buffer] as const;\n    }\n\n    start = inx + 1;\n  }\n\n  return [-1, buffer] as const;\n}\n\n// ===========================================================================\nexport async function readToDoubleCRLF(reader: AsyncIterReader) {\n  const chunks = [];\n  let size = 0;\n\n  let inx = 0;\n\n  let lastChunk = null;\n\n  const iter = reader[Symbol.asyncIterator]();\n\n  for await (let chunk of iter) {\n    [inx, chunk] = await indexOfDoubleCRLF(chunk, iter);\n\n    if (inx >= 0) {\n      lastChunk = chunk;\n      break;\n    }\n\n    chunks.push(chunk);\n    size += chunk.byteLength;\n  }\n\n  if (lastChunk) {\n    const [first, remainder] = splitChunk(lastChunk, inx + 1);\n    chunks.push(first);\n    size += first.byteLength;\n\n    reader.unread(remainder);\n  } else if (!chunks.length) {\n    return \"\";\n  }\n\n  return decoder.decode(concatChunks(chunks, size));\n}\n\n// ===========================================================================\n","import { BaseAsyncIterReader, AsyncIterReader, LimitReader } from \"./readers\";\nimport { StatusAndHeaders } from \"./statusandheaders\";\nimport uuid from \"uuid-random\";\n\nconst decoder = new TextDecoder(\"utf-8\");\nconst encoder = new TextEncoder();\n\nconst WARC_1_1 = \"WARC/1.1\";\nconst WARC_1_0 = \"WARC/1.0\";\n\nconst REVISIT_PROFILE_1_0 =\n  \"http://netpreserve.org/warc/1.0/revisit/identical-payload-digest\";\nconst REVISIT_PROFILE_1_1 =\n  \"http://netpreserve.org/warc/1.1/revisit/identical-payload-digest\";\n\nconst defaultRecordCT = {\n  warcinfo: \"application/warc-fields\",\n  response: \"application/http; msgtype=response\",\n  revisit: \"application/http; msgtype=response\",\n  request: \"application/http; msgtype=request\",\n  metadata: \"application/warc-fields\",\n};\n\n// ===========================================================================\ntype WARCRecordOpts = {\n  url?: string;\n  date?: string;\n  type?: keyof typeof defaultRecordCT;\n  warcHeaders?: any;\n  filename?: string;\n  httpHeaders?: Record<string, string>;\n  statusline?: string;\n  warcVersion?: typeof WARC_1_0 | typeof WARC_1_1;\n  keepHeadersCase?: boolean;\n  refersToUrl?: string;\n  refersToDate?: string;\n};\nexport class WARCRecord<\n  T extends\n    | AsyncGenerator<Uint8Array, void, unknown>\n    | BaseAsyncIterReader = AsyncGenerator<Uint8Array, void, unknown>\n> extends BaseAsyncIterReader {\n  static create(\n    {\n      url,\n      date,\n      type,\n      warcHeaders = {},\n      filename = \"\",\n      httpHeaders = {},\n      statusline = \"HTTP/1.1 200 OK\",\n      warcVersion = WARC_1_0,\n      keepHeadersCase = true,\n      refersToUrl = undefined,\n      refersToDate = undefined,\n    }: WARCRecordOpts = {},\n    reader: AsyncGenerator<Uint8Array, void, unknown>\n  ) {\n    function checkDate(d: string) {\n      const date = d;\n      if (warcVersion === WARC_1_0) {\n        d = d.split(\".\")[0]!;\n        if (d.charAt(date.length - 1) != \"Z\") {\n          d += \"Z\";\n        }\n      }\n      return d;\n    }\n\n    date = checkDate(date || new Date().toISOString());\n\n    warcHeaders = { ...warcHeaders };\n    if (type === \"warcinfo\") {\n      if (filename) {\n        warcHeaders[\"WARC-Filename\"] = filename;\n      }\n    } else {\n      warcHeaders[\"WARC-Target-URI\"] = url;\n    }\n\n    warcHeaders[\"WARC-Date\"] = date;\n    warcHeaders[\"WARC-Type\"] = type;\n\n    if (type === \"revisit\") {\n      warcHeaders[\"WARC-Profile\"] =\n        warcVersion === WARC_1_1 ? REVISIT_PROFILE_1_1 : REVISIT_PROFILE_1_0;\n      warcHeaders[\"WARC-Refers-To-Target-URI\"] = refersToUrl;\n      warcHeaders[\"WARC-Refers-To-Date\"] = checkDate(\n        refersToDate || new Date().toISOString()\n      );\n    }\n\n    warcHeaders = new StatusAndHeaders({\n      statusline: warcVersion,\n      headers: keepHeadersCase\n        ? new Map(Object.entries(warcHeaders))\n        : new Headers(warcHeaders),\n    });\n\n    if (!warcHeaders.headers.get(\"WARC-Record-ID\")) {\n      warcHeaders.headers.set(\"WARC-Record-ID\", `<urn:uuid:${uuid()}>`);\n    }\n\n    if (!warcHeaders.headers.get(\"Content-Type\")) {\n      warcHeaders.headers.set(\n        \"Content-Type\",\n        (type && defaultRecordCT[type]) || \"application/octet-stream\"\n      );\n    }\n\n    if (!reader) {\n      const emptyReader: () => AsyncGenerator<never, void, unknown> =\n        async function* () {};\n      reader = emptyReader();\n    }\n\n    const record = new WARCRecord({ warcHeaders, reader });\n    let headers: Map<string, string> | Headers | null = null;\n    let entries: [string, string][] = [];\n\n    switch (type) {\n      case \"response\":\n      case \"request\":\n      case \"revisit\":\n        entries = Object.entries(httpHeaders);\n        headers = keepHeadersCase ? new Map(entries) : new Headers(httpHeaders);\n\n        // for revisit records, if there are no http headers, don't add statusline\n        // for other request/response, add an empty statusline-only block\n        if (entries.length > 0 || type !== \"revisit\") {\n          record.httpHeaders = new StatusAndHeaders({ statusline, headers });\n        }\n        break;\n    }\n\n    return record;\n  }\n\n  static createWARCInfo(\n    opts: WARCRecordOpts = {},\n    info: Record<string, string>\n  ) {\n    async function* genInfo() {\n      for (const [name, value] of Object.entries(info)) {\n        yield encoder.encode(`${name}: ${value}\\r\\n`);\n      }\n    }\n\n    opts.type = \"warcinfo\";\n\n    return WARCRecord.create(opts, genInfo());\n  }\n\n  warcHeaders: StatusAndHeaders;\n  _reader: T;\n  _contentReader: BaseAsyncIterReader | null;\n  payload: Uint8Array | null;\n  httpHeaders: StatusAndHeaders | null;\n  consumed: \"content\" | \"raw\" | \"skipped\" | \"\";\n\n  _offset = 0;\n  _length = 0;\n\n  method = \"\";\n  requestBody = \"\";\n  _urlkey = \"\";\n\n  constructor({\n    warcHeaders,\n    reader,\n  }: {\n    warcHeaders: StatusAndHeaders;\n    reader: T;\n  }) {\n    super();\n\n    this.warcHeaders = warcHeaders;\n\n    this._reader = reader;\n    this._contentReader = null;\n\n    this.payload = null;\n    this.httpHeaders = null;\n\n    this.consumed = \"\";\n\n    this.fixUp();\n  }\n\n  getResponseInfo() {\n    const httpHeaders = this.httpHeaders;\n\n    if (!httpHeaders) {\n      return null;\n    }\n\n    // match parameters for Response(..., initOpts);\n    return {\n      headers: httpHeaders.headers,\n      status: httpHeaders.statusCode,\n      statusText: httpHeaders.statusText,\n    };\n  }\n\n  fixUp() {\n    // Fix wget-style error where WARC-Target-URI is wrapped in <>\n    const uri = this.warcHeaders.headers.get(\"WARC-Target-URI\");\n    if (uri && uri.startsWith(\"<\") && uri.endsWith(\">\")) {\n      this.warcHeaders.headers.set(\"WARC-Target-URI\", uri.slice(1, -1));\n    }\n  }\n\n  override async readFully(isContent = false) {\n    // if have httpHeaders, need to consider transfer and content decoding is decoding content vs raw data\n    if (this.httpHeaders) {\n      // if payload is empty, just return\n      if (this.payload && !this.payload.length) {\n        return this.payload;\n      }\n\n      // otherwise, can't serialize payload as raw if already started reading\n      if (this._contentReader && !isContent) {\n        throw new TypeError(\n          \"WARC Record decoding already started, but requesting raw payload\"\n        );\n      }\n\n      // reading content, but already consumed raw data, convert\n      if (isContent && this.consumed === \"raw\" && this.payload) {\n        return await this._createDecodingReader([this.payload]).readFully();\n      }\n    }\n\n    if (this.payload) {\n      return this.payload;\n    }\n\n    if (isContent) {\n      this.payload = await super.readFully();\n      this.consumed = \"content\";\n    } else {\n      this.payload = (await WARCRecord.readFully(this._reader))[1];\n      this.consumed = \"raw\";\n    }\n\n    return this.payload;\n  }\n\n  get reader() {\n    if (this._contentReader) {\n      throw new TypeError(\n        \"WARC Record decoding already started, but requesting raw payload\"\n      );\n    }\n\n    return this._reader;\n  }\n\n  get contentReader() {\n    if (!this.httpHeaders) {\n      return this._reader;\n    }\n\n    if (!this._contentReader) {\n      this._contentReader = this._createDecodingReader(this._reader);\n    }\n\n    return this._contentReader;\n  }\n\n  _createDecodingReader(\n    source:\n      | AsyncGenerator<Uint8Array, void, unknown>\n      | BaseAsyncIterReader\n      | Uint8Array[]\n  ) {\n    // only called if this.httpHeaders !== null\n    if (!this.httpHeaders) {\n      throw new Error(\n        \"WARCRecord cannot call _createDecodingReader when this.httpHeaders === null\"\n      );\n    }\n\n    let contentEnc = this.httpHeaders.headers.get(\"Content-Encoding\") as string;\n    let transferEnc = this.httpHeaders.headers.get(\n      \"Transfer-Encoding\"\n    ) as string;\n\n    const chunked = transferEnc === \"chunked\";\n\n    // Transfer-Encoding is not chunked and no Content-Encoding\n    // try Transfer-Encoding as Content-Encoding\n    if (!contentEnc && !chunked) {\n      contentEnc = transferEnc;\n    }\n\n    return new AsyncIterReader(source, contentEnc, chunked);\n  }\n\n  async readlineRaw(maxLength?: number) {\n    if (this.consumed) {\n      throw new Error(\n        \"Record already consumed. Perhaps a promise was not awaited?\"\n      );\n    }\n    if (\"readlineRaw\" in this.contentReader) {\n      return this.contentReader.readlineRaw(maxLength);\n    }\n    throw new Error(\n      \"WARCRecord cannot call readlineRaw on this.contentReader if it does not have the function\"\n    );\n  }\n\n  async contentText() {\n    const payload = await this.readFully(true);\n    return decoder.decode(payload.buffer);\n  }\n\n  async *[Symbol.asyncIterator]() {\n    for await (const chunk of this.contentReader) {\n      yield chunk;\n      if (this.consumed) {\n        throw new Error(\n          \"Record already consumed.. Perhaps a promise was not awaited?\"\n        );\n      }\n    }\n\n    this.consumed = \"content\";\n  }\n\n  async skipFully() {\n    if (this.consumed) {\n      return;\n    }\n    if (this._reader instanceof LimitReader) {\n      const res = await this._reader.skipFully();\n      this.consumed = \"skipped\";\n      return res;\n    }\n    throw new Error(\n      \"WARCRecord cannot call skipFully on this._reader if it is not a LimitReader\"\n    );\n  }\n\n  warcHeader(name: string) {\n    return this.warcHeaders.headers.get(name);\n  }\n\n  get warcType() {\n    return this.warcHeaders.headers.get(\"WARC-Type\");\n  }\n\n  get warcTargetURI() {\n    const uri = this.warcHeaders.headers.get(\"WARC-Target-URI\");\n    if (!uri) {\n      throw new Error(\"WARCRecord headers do not contain WARC-Target-URI\");\n    }\n    return uri;\n  }\n\n  get warcDate() {\n    return this.warcHeaders.headers.get(\"WARC-Date\");\n  }\n\n  get warcRefersToTargetURI() {\n    return this.warcHeaders.headers.get(\"WARC-Refers-To-Target-URI\");\n  }\n\n  get warcRefersToDate() {\n    return this.warcHeaders.headers.get(\"WARC-Refers-To-Date\");\n  }\n\n  get warcPayloadDigest() {\n    return this.warcHeaders.headers.get(\"WARC-Payload-Digest\");\n  }\n\n  get warcBlockDigest() {\n    return this.warcHeaders.headers.get(\"WARC-Block-Digest\");\n  }\n\n  get warcContentType() {\n    return this.warcHeaders.headers.get(\"Content-Type\");\n  }\n\n  get warcContentLength() {\n    return Number(this.warcHeaders.headers.get(\"Content-Length\"));\n  }\n}\n\n// ===========================================================================\n","import { ReadStream } from \"fs\";\nimport { StatusAndHeadersParser, StatusAndHeaders } from \"./statusandheaders\";\nimport { WARCRecord } from \"./warcrecord\";\nimport { AsyncIterReader, LimitReader } from \"./readers\";\n\nconst decoder = new TextDecoder();\nconst EMPTY = new Uint8Array([]);\n\ntype WarcParserOpts = {\n  keepHeadersCase?: boolean;\n  parseHttp?: boolean;\n};\n\n// ===========================================================================\nexport class WARCParser {\n  static parse(\n    source:\n      | ReadableStream<Uint8Array>\n      | AsyncGenerator<Uint8Array, void, unknown>,\n    options: WarcParserOpts\n  ) {\n    return new WARCParser(source, options).parse();\n  }\n\n  static iterRecords(\n    source:\n      | ReadableStream<Uint8Array>\n      | AsyncGenerator<Uint8Array, void, unknown>,\n    options: WarcParserOpts\n  ) {\n    return new WARCParser(source, options)[Symbol.asyncIterator]();\n  }\n\n  _offset: number;\n  _warcHeadersLength: number;\n\n  _headersClass: typeof Map | typeof Headers;\n  _parseHttp: boolean;\n\n  _atRecordBoundary: boolean;\n\n  _reader: AsyncIterReader;\n\n  _record: WARCRecord<LimitReader> | null;\n\n  constructor(\n    source:\n      | ReadStream\n      | ReadableStream<Uint8Array>\n      | AsyncGenerator<Uint8Array, void, unknown>,\n    { keepHeadersCase = false, parseHttp = true }: WarcParserOpts = {}\n  ) {\n    this._offset = 0;\n    this._warcHeadersLength = 0;\n\n    this._headersClass = keepHeadersCase ? Map : Headers;\n    this._parseHttp = parseHttp;\n\n    this._atRecordBoundary = true;\n\n    if (!(source instanceof AsyncIterReader)) {\n      this._reader = new AsyncIterReader(source);\n    } else {\n      this._reader = source;\n    }\n\n    this._record = null;\n  }\n\n  async readToNextRecord() {\n    let nextline;\n\n    if (!this._atRecordBoundary && this._reader && this._record) {\n      await this._record.skipFully();\n\n      let lineLen = 0;\n\n      nextline = await this._reader.readlineRaw();\n      if (!nextline) {\n        nextline = EMPTY;\n      } else {\n        lineLen = nextline.byteLength - 1;\n\n        while (lineLen >= 0) {\n          const value = nextline[lineLen - 1];\n          if (value !== 10 && value !== 13) {\n            break;\n          }\n          lineLen--;\n        }\n      }\n\n      if (lineLen) {\n        console.warn(`Content-Length Too Small: Record not followed by newline, \\\nRemainder Length: ${lineLen}, \\\nOffset: ${this._reader.getRawOffset() - nextline.byteLength}`);\n      }\n\n      if (this._reader.compressed) {\n        await this._reader.readSize(2, true);\n        nextline = EMPTY;\n      } else {\n        nextline = await this._reader.readlineRaw();\n\n        // consume remaining new lines\n        while (nextline && nextline.byteLength === 2) {\n          nextline = await this._reader.readlineRaw();\n        }\n      }\n    }\n\n    this._atRecordBoundary = true;\n    return nextline ? decoder.decode(nextline) : \"\";\n  }\n\n  _initRecordReader(warcHeaders: StatusAndHeaders) {\n    return new LimitReader(\n      this._reader,\n      Number(warcHeaders.headers.get(\"Content-Length\") || 0)\n    );\n  }\n\n  async parse() {\n    const firstLine = await this.readToNextRecord();\n\n    this._offset = this._reader.getRawOffset() - firstLine.length;\n\n    const headersParser = new StatusAndHeadersParser();\n\n    const warcHeaders = await headersParser.parse(this._reader, {\n      firstLine,\n      headersClass: this._headersClass,\n    });\n\n    if (!warcHeaders) {\n      return null;\n    }\n\n    this._warcHeadersLength = this._reader.getReadOffset();\n\n    const record = new WARCRecord({\n      warcHeaders,\n      reader: this._initRecordReader(warcHeaders),\n    });\n\n    this._atRecordBoundary = false;\n    this._record = record;\n\n    if (this._parseHttp) {\n      switch (record.warcType) {\n        case \"response\":\n        case \"request\":\n          await this._addHttpHeaders(record, headersParser);\n          break;\n\n        case \"revisit\":\n          if (record.warcContentLength > 0) {\n            await this._addHttpHeaders(record, headersParser);\n          }\n          break;\n      }\n    }\n\n    return record;\n  }\n\n  get offset() {\n    return this._offset;\n  }\n\n  get recordLength() {\n    return this._reader.getRawLength(this._offset);\n  }\n\n  async *[Symbol.asyncIterator]() {\n    let record = null;\n\n    while ((record = await this.parse()) !== null) {\n      yield record;\n    }\n\n    this._record = null;\n  }\n\n  async _addHttpHeaders(\n    record: WARCRecord<LimitReader>,\n    headersParser: StatusAndHeadersParser\n  ) {\n    const httpHeaders = await headersParser.parse(this._reader, {\n      headersClass: this._headersClass,\n    });\n    record.httpHeaders = httpHeaders;\n\n    const headersLen = this._reader.getReadOffset() - this._warcHeadersLength;\n    if (record.reader.setLimitSkip) {\n      record.reader.setLimitSkip(record.warcContentLength - headersLen);\n    }\n  }\n}\n\n// ===========================================================================\n","import { WARCParser } from \"./warcparser\";\nimport { WARCRecord } from \"./warcrecord\";\nimport { LimitReader } from \"./readers\";\n\nconst DEFAULT_FIELDS = \"offset,warc-type,warc-target-uri\".split(\",\");\n\nimport { postToGetUrl, getSurt } from \"./utils\";\nimport { IndexCommandArgs, CdxIndexCommandArgs } from \"../commands\";\nimport { StreamResult, StreamResults, Request } from \"./types\";\n\n// ===========================================================================\nabstract class BaseIndexer {\n  opts: IndexCommandArgs;\n  out: NodeJS.WriteStream;\n  fields: string[];\n  parseHttp: boolean;\n\n  constructor(opts: IndexCommandArgs, out: NodeJS.WriteStream) {\n    this.opts = opts;\n    this.out = out;\n    this.fields = opts.f ? opts.f.split(\",\") : DEFAULT_FIELDS;\n    this.parseHttp = false;\n  }\n\n  serialize(result: Record<string, any>) {\n    return JSON.stringify(result) + \"\\n\";\n  }\n\n  write(result: Record<string, any>) {\n    this.out.write(this.serialize(result));\n  }\n\n  async run(files: StreamResults) {\n    for await (const result of this.iterIndex(files)) {\n      this.write(result);\n    }\n  }\n\n  async *iterIndex(files: StreamResults) {\n    const params = { strictHeaders: true, parseHttp: this.parseHttp };\n\n    for (const { filename, reader } of files) {\n      const parser = new WARCParser(reader, params);\n\n      yield* this.iterRecords(parser, filename);\n    }\n  }\n\n  async *iterRecords(parser: WARCParser, filename: string) {\n    for await (const record of parser) {\n      await record.skipFully();\n      const result = this.indexRecord(record, parser, filename);\n      if (result) {\n        yield result;\n      }\n    }\n  }\n\n  filterRecord?(record: WARCRecord<LimitReader>): boolean;\n\n  indexRecord(\n    record: WARCRecord<LimitReader>,\n    parser: WARCParser,\n    filename: string\n  ): Record<string, any> | null {\n    if (this.filterRecord && !this.filterRecord(record)) {\n      return null;\n    }\n\n    const result: Record<string, any> = {};\n\n    const offset = parser.offset;\n    const length = parser.recordLength;\n\n    const special = { offset, length, filename };\n\n    for (const field of this.fields) {\n      if (field in special) {\n        result[field] = special[field as keyof typeof special];\n      } else {\n        this.setField(field, record, result);\n      }\n    }\n\n    return result;\n  }\n\n  setField(\n    field: string,\n    record: WARCRecord<LimitReader>,\n    result: Record<string, any>\n  ) {\n    const value = this.getField(field, record);\n    if (value != null) {\n      result[field] = value;\n    }\n  }\n\n  getField(field: string, record: WARCRecord<LimitReader>) {\n    if (field === \"http:status\") {\n      if (\n        record.httpHeaders &&\n        (record.warcType === \"response\" || record.warcType === \"revisit\")\n      ) {\n        return record.httpHeaders.statusCode;\n      }\n      return null;\n    }\n\n    if (field.startsWith(\"http:\")) {\n      if (record.httpHeaders) {\n        return record.httpHeaders.headers.get(field.slice(5));\n      }\n      return null;\n    }\n\n    return record.warcHeaders.headers.get(field);\n  }\n}\n\n// ===========================================================================\nexport class Indexer extends BaseIndexer {\n  constructor(opts: IndexCommandArgs, out: NodeJS.WriteStream) {\n    super(opts, out);\n\n    for (const field of this.fields) {\n      if (field.startsWith(\"http:\")) {\n        this.parseHttp = true;\n        break;\n      }\n    }\n  }\n}\n\n// ===========================================================================\nconst DEFAULT_CDX_FIELDS =\n  \"urlkey,timestamp,url,mime,status,digest,length,offset,filename\".split(\",\");\nconst DEFAULT_LEGACY_CDX_FIELDS =\n  \"urlkey,timestamp,url,mime,status,digest,redirect,meta,length,offset,filename\".split(\n    \",\"\n  );\n\n// ===========================================================================\nexport class CDXIndexer extends Indexer {\n  includeAll: boolean;\n  noSurt: boolean;\n  _lastRecord: WARCRecord<LimitReader> | null;\n\n  constructor(opts: CdxIndexCommandArgs, out: NodeJS.WriteStream) {\n    super(opts as unknown as IndexCommandArgs, out);\n    this.includeAll = Boolean(opts.a);\n    this.fields = DEFAULT_CDX_FIELDS;\n    this.parseHttp = true;\n    this.noSurt = Boolean(opts.noSurt);\n    this._lastRecord = null;\n\n    switch (opts.format) {\n      case \"cdxj\":\n        this.serialize = this.serializeCDXJ;\n        break;\n\n      case \"cdx\":\n        this.serialize = this.serializeCDX11;\n        break;\n\n      case \"json\":\n      default:\n        // default write\n        break;\n    }\n  }\n\n  override async *iterRecords(parser: WARCParser, filename: string) {\n    this._lastRecord = null;\n\n    for await (const record of parser) {\n      await record.readFully();\n      const result = this.indexRecord(record, parser, filename);\n      if (result) {\n        yield result;\n      }\n    }\n\n    const result = this.indexRecord(null, parser, filename);\n    if (result) {\n      yield result;\n    }\n  }\n\n  override filterRecord(record: WARCRecord<LimitReader>) {\n    if (this.includeAll) {\n      return true;\n    }\n\n    const type = record.warcType;\n    if (type === \"request\" || type === \"warcinfo\") {\n      return false;\n    }\n\n    return true;\n  }\n\n  override indexRecord(\n    record: WARCRecord<LimitReader> | null,\n    parser: WARCParser,\n    filename: string\n  ) {\n    if (this.includeAll) {\n      if (!record) {\n        return null;\n      }\n      return super.indexRecord(record, parser, filename);\n    }\n\n    const lastRecord = this._lastRecord;\n\n    if (record) {\n      record._offset = parser.offset;\n      record._length = parser.recordLength;\n    }\n\n    if (!lastRecord) {\n      this._lastRecord = record;\n      return null;\n    }\n\n    if (!record || lastRecord.warcTargetURI != record.warcTargetURI) {\n      this._lastRecord = record;\n      return this.indexRecordPair(lastRecord, null, parser, filename);\n    }\n\n    if (record.warcType === \"request\" && lastRecord.warcType === \"response\") {\n      this._lastRecord = null;\n      return this.indexRecordPair(lastRecord, record, parser, filename);\n    } else if (\n      record.warcType === \"response\" &&\n      lastRecord.warcType === \"request\"\n    ) {\n      this._lastRecord = null;\n      return this.indexRecordPair(record, lastRecord, parser, filename);\n    } else {\n      this._lastRecord = record;\n      return this.indexRecordPair(lastRecord, null, parser, filename);\n    }\n  }\n\n  indexRecordPair(\n    record: WARCRecord<LimitReader>,\n    reqRecord: WARCRecord<LimitReader> | null,\n    parser: WARCParser,\n    filename: string\n  ) {\n    let method;\n    let requestBody;\n    let url = record.warcTargetURI;\n\n    if (\n      reqRecord &&\n      reqRecord.httpHeaders &&\n      reqRecord.httpHeaders.method !== \"GET\"\n    ) {\n      const request: Request = {\n        url,\n        method: reqRecord.httpHeaders.method,\n        headers: reqRecord.httpHeaders.headers,\n        postData: reqRecord.payload,\n      };\n\n      method = request.method;\n\n      if (postToGetUrl(request)) {\n        requestBody = request.requestBody;\n        record.method = method;\n        record.requestBody = requestBody;\n        url = request.url;\n      }\n    }\n\n    record._urlkey = url;\n\n    const res = super.indexRecord(record, parser, filename);\n    if (res) {\n      if (record && record._offset !== undefined) {\n        res[\"offset\"] = record._offset;\n        res[\"length\"] = record._length;\n      }\n      if (method) {\n        res[\"method\"] = method;\n      }\n      if (requestBody) {\n        res[\"requestBody\"] = requestBody;\n      }\n    }\n\n    return res;\n  }\n\n  serializeCDXJ(result: Record<string, any>) {\n    const { urlkey, timestamp } = result;\n    // FIXME: does this work?\n    delete result[\"urlkey\"];\n    delete result[\"timestamp\"];\n\n    return `${urlkey} ${timestamp} ${JSON.stringify(result)}\\n`;\n  }\n\n  serializeCDX11(result: Record<string, any>) {\n    const value = [];\n\n    for (const field of DEFAULT_LEGACY_CDX_FIELDS) {\n      value.push(result[field] != undefined ? result[field] : \"-\");\n    }\n\n    return value.join(\" \") + \"\\n\";\n  }\n\n  override getField(field: string, record: WARCRecord<LimitReader>) {\n    let value = null;\n\n    switch (field) {\n      case \"urlkey\":\n        value = record._urlkey ? record._urlkey : record.warcTargetURI;\n        return this.noSurt ? value : getSurt(value);\n\n      case \"timestamp\":\n        value = record.warcDate ?? \"\";\n        return value.replace(/[-:T]/g, \"\").slice(0, 14);\n\n      case \"url\":\n        return record.warcTargetURI;\n\n      case \"mime\":\n        switch (record.warcType) {\n          case \"revisit\":\n            return \"warc/revisit\";\n\n          case \"response\":\n          case \"request\":\n            field = \"http:content-type\";\n            break;\n\n          default:\n            field = \"content-type\";\n        }\n        value = super.getField(field, record);\n        return value ? value.toString().split(\";\", 1)[0]?.trim() : null;\n\n      case \"status\":\n        return super.getField(\"http:status\", record);\n\n      case \"digest\":\n        value = record.warcPayloadDigest;\n        return value ? value.split(\":\", 2)[1] : null;\n\n      default:\n        return null;\n    }\n  }\n}\n","#!/usr/bin/env node\nimport { main } from \"./commands\";\n\nmain();\n"],"mappings":"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","names":["import_fs","import_path","import_yargs","import_yargs","indexCommandArgs","yargs","cdxIndexCommandArgs","import_fs","import_pako","binaryToString","data","string","accumulator","value","rxEscape","getSurt","url","urlLower","urlObj","surt","key","rx","postToGetUrl","request","method","headers","postData","requestMime","decodeIfNeeded","query","jsonToQueryString","content_type","mfdToQueryString","appendRequestQuery","start","jsonToQueryParams","json","ignoreInvalid","q","dupes","getKey","k","v","e","mfdToQueryParams","mfd","contentType","params","boundary","parts","i","m","concatChunks","chunks","size","buffer","offset","chunk","splitChunk","inx","decoder","NoConcatInflator","options","reader","status","BaseAsyncIterReader","iter","chunks","size","chunk","concatChunks","streamIter","controller","result","maxLength","lineBuff","line","isIterator","input","isAsyncIterator","AsyncIterReader","streamOrIter","compressed","dechunk","source","res","newSize","first","sep","newValue","value","original","avail_in","inx","lastChunk","lineInx","remainder","splitChunk","sizeLimit","skip","prevOffset","LimitReader","limit","origLimit","CRLF","CRLFCRLF","decoder","StatusAndHeaders","statusline","headers","buff","name","value","encoder","parts","splitRemainder","StatusAndHeadersParser","reader","headersClass","firstLine","fullStatusLine","headerBuff","readToDoubleCRLF","start","nameEnd","valueStart","valueEnd","str","sep","limit","newParts","indexOfDoubleCRLF","buffer","iter","i","inx","newBuff","chunks","size","lastChunk","chunk","first","remainder","splitChunk","concatChunks","import_uuid_random","decoder","encoder","WARC_1_1","WARC_1_0","REVISIT_PROFILE_1_0","REVISIT_PROFILE_1_1","defaultRecordCT","WARCRecord","BaseAsyncIterReader","warcHeaders","reader","url","date","type","filename","httpHeaders","statusline","warcVersion","keepHeadersCase","refersToUrl","refersToDate","checkDate","d","StatusAndHeaders","uuid","record","headers","entries","opts","info","genInfo","name","value","uri","isContent","source","contentEnc","transferEnc","chunked","AsyncIterReader","maxLength","payload","chunk","LimitReader","res","decoder","EMPTY","WARCParser","source","options","keepHeadersCase","parseHttp","AsyncIterReader","nextline","lineLen","value","warcHeaders","LimitReader","firstLine","headersParser","StatusAndHeadersParser","record","WARCRecord","httpHeaders","headersLen","DEFAULT_FIELDS","BaseIndexer","opts","out","result","files","params","filename","reader","parser","WARCParser","record","offset","length","special","field","value","Indexer","DEFAULT_CDX_FIELDS","DEFAULT_LEGACY_CDX_FIELDS","CDXIndexer","type","lastRecord","reqRecord","method","requestBody","url","request","postToGetUrl","res","urlkey","timestamp","_a","getSurt","BUFF_SIZE","main","args","out","promise","yargs","indexCommandArgs","Indexer","loadStreams","cdxIndexCommandArgs","CDXIndexer","filenames","accumulator","filename","reader","main"]}